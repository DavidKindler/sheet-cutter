{"version":3,"sources":["helpers.ts","model.ts","Panel.tsx","JobPanelViewer.tsx","JobViewer.tsx","PanelOperations.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["handleStringChange","handler","event","target","value","CutDirection","PanelComp","props","state","prevProps","prevState","panel","this","style","height","width","border","material","React","Component","JobPanelViewer","panelsToGroup","madePanels","inventoryPanels","groups","_","groupBy","c","originalSource","notMadePanels","map","startPanels","childPanels","id","length","marginTop","pageBreakInside","WebkitPrintColorAdjust","label","display","position","backgroundColor","childPanel","undefined","originalSourcePos","isInventory","includes","displayText","top","left","justifyContent","alignItems","marginLeft","child","JobViewer","job","result","availablePanels","panelsMade","panelInventory","panelsNotPlaced","nextId","determineCutOrderForJob","cloneDeep","forEach","parentSource","panelsNeed","neededPanels","sort","comparePanels","cutsInOrder","panelToPlace","shift","console","log","panelsToHoldIt","filter","parentPanel","settings","getBigAndSmallSideOfPanel","parentBig","bigDim","parentSmall","smallDim","childBig","childSmall","willFirstPanelHoldSecond","push","bestHoldingPanel","maxBy","getPanelWaste","error","remove","bestCuts","wasteHeight","wasteWidth","mustRotate","wasteHeightRot","wasteWidthRot","canRotate","normalCuts","getBestCutSingleTest","rotatedCuts","cuts","biggestArea","getBestCut","cut1","getNewPanelsFromCut","goodPanel","wastePanel","cut2","finalPanel","wastePanel2","warn","originalPanel","cut","parentSourcePos","addSourcePos","cutDirection","HORIZONTAL","cutPosition","bladeKerf","Math","max","pos1","pos2","widthToUse","heightToUse","needsVerticalCut","needsHorizontalCut","kerf","verticalCut","VERTICAL","panelIdToCut","horizontalCut","biggestAreaIfHorizontalFirst","biggestAreaIfVerticalFirst","cutLengthIfHorizontalFirst","cutLengthIfVerticalFirst","optimizeArea","Number","MAX_VALUE","panelA","panelB","aBig","aSmall","bBig","bSmall","min","numOnlyRegex","App","inputText","results","kerfText","onChange","setState","type","checked","onClick","handleProcessClick","newJob","input","lines","split","isFirst","line","trim","parts","replaceAll","qty","inventory","toLowerCase","i","newPanel","convertCsvToJob","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"uNAOO,SAASA,EAAmBC,GACjC,OAAO,SAACC,GAAD,OACLD,EAASC,EAAMC,OAA4BC,Q,ICqBnCC,E,wBCtBCC,EAAb,kDACE,WAAYC,GAAoB,IAAD,8BAC7B,cAAMA,IAEDC,MAAQ,GAHgB,EADjC,4GASqBC,EAAuBC,MAT5C,+BAYI,IAAMC,EAAQC,KAAKL,MAAMI,MACzB,OACE,qBACEE,MAAO,CACLC,OAAuB,EAAfH,EAAMG,OACdC,MAAqB,EAAdJ,EAAMI,MACbC,OAAQ,mBAJZ,SAOGL,EAAMM,SAAW,KAAON,EAAMG,OAAS,KAAOH,EAAMI,YArB7D,GAA+BG,IAAMC,WCMxBC,EAAb,kDAIE,WAAYb,GAA6B,IAAD,8BACtC,cAAMA,IAEDC,MAAQ,GAHyB,EAJ1C,4GAaIC,EACAC,MAdJ,+BAiBY,IAAD,OACDW,EAAa,sBACdT,KAAKL,MAAMe,YADG,YAEdV,KAAKL,MAAMgB,kBAMVC,EAASC,IAAEC,QAAQL,GAAe,SAACM,GAAD,OAAOA,EAAEC,kBAEjD,OACE,gCACGhB,KAAKL,MAAMsB,cAAcC,KAAI,SAACnB,GAC7B,OAAO,cAAC,EAAD,CAAWA,MAAOA,OAG1BC,KAAKL,MAAMwB,YAAYD,KAAI,SAACnB,GAC3B,IAAMqB,EAAcR,EAAOb,EAAMsB,IAGjC,OAA2B,IAAvBD,EAAYE,OACP,KAIP,sBACErB,MAAO,CACLsB,UAAW,GACXC,gBAAiB,QACjBC,uBAAwB,SAJ5B,UAQE,8BACG1B,EAAM2B,MADT,MACmB3B,EAAMG,OADzB,MACoCH,EAAMI,SAE1C,sBAAKF,MAAO,CAAE0B,QAAS,QAAvB,UACE,qBACE1B,MAAO,CACLC,OAAuB,EAAfH,EAAMG,OACdC,MAAqB,EAAdJ,EAAMI,MACbC,OAAQ,kBACRwB,SAAU,WACVC,gBAAiB,OANrB,SASGT,EAAYF,KAAI,SAACY,GAChB,QACmCC,IAAjCD,EAAWE,mBACXF,EAAW5B,QAAU,GACrB4B,EAAW3B,OAAS,EAEpB,OAAO,KAGT,IAAM8B,EAAc,EAAKtC,MAAMgB,gBAAgBuB,SAC7CJ,GAGIK,EAAcF,EAAc,GAAKH,EAAWT,GAClD,OACE,qBAEEpB,MAAO,CACLC,OAA4B,EAApB4B,EAAW5B,OACnBC,MAA0B,EAAnB2B,EAAW3B,MAClBC,OAAQ,kBACRwB,SAAU,WACVQ,IAAwC,EAAnCN,EAAWE,kBAAkBI,IAClCC,KAA0C,EAApCP,EAAWE,kBAAkBK,KACnCR,gBAAiBI,EAAc,OAAS,QACxCN,QAAS,OACTW,eAAgB,SAChBC,WAAY,UAZhB,SAeE,4BAAIJ,KAdCL,EAAWT,SAmBxB,qBAAKpB,MAAO,CAAEuC,WAAY,IAA1B,SACGpB,EAAYF,KAAI,SAACuB,GAKhB,OAJoB,EAAK9C,MAAMgB,gBAAgBuB,SAC7CO,GAIO,KAIP,8BACGA,EAAMpB,GADT,MACgBoB,EAAMf,MADtB,MACgCe,EAAMvC,OADtC,KACgD,IAC7CuC,EAAMtC,QAFDsC,EAAMpB,cA7DjBtB,EAAMsB,cAjDzB,GAAoCf,IAAMC,WCF7BmC,EAAb,kDACE,WAAY/C,GAAwB,IAAD,8BACjC,cAAMA,IAEDC,MAAQ,GAHoB,EADrC,4GASqBC,EAA2BC,MAThD,+BAYI,IAAM6C,EAAM3C,KAAKL,MAAMgD,IACjBC,EAAS5C,KAAKL,MAAMiD,OAE1B,YAAYb,IAARY,QAAgCZ,IAAXa,EAChB,6BAIP,8BACE,cAAC,EAAD,CACEzB,YAAawB,EAAIE,gBACjBnC,WAAYkC,EAAOE,WACnBnC,gBAAiBiC,EAAOG,eACxB9B,cAAe2B,EAAOI,wBAzBhC,GAA+B1C,IAAMC,W,kBHkBzBd,O,uBAAAA,I,4BAAAA,M,KInBZ,IAAIwD,EAAS,EAEN,SAASC,EAAwBP,GAKtC,IAAMI,EAAiBlC,IAAEsC,UAAUR,EAAIE,iBAGvCE,EAAeK,SAAQ,SAACrC,GACtBA,EAAEC,eAAiBD,EAAEM,GACrBN,EAAEsC,aAAetC,EAAEM,MAGrB,IAAMiC,EAAazC,IAAEsC,UAAUR,EAAIY,cACnCD,EAAWE,KAAKC,GAQhB,IANA,IAAMT,EAAkB,GAClBF,EAAa,GACbY,EAAc,GAlB8C,aAuBhE,IAAMC,EAAeL,EAAWM,QAEhC,QAAqB7B,IAAjB4B,EAEF,OADAE,QAAQC,IAAI,uBACZ,QAKF,IAAMC,EAAiBhB,EACpBiB,QAAO,SAACjD,GAAD,OAAOA,EAAEV,WAAasD,EAAatD,YAC1C2D,QAAO,SAACjD,GAAD,OA6Wd,SACEkD,EACAnC,EACAoC,GACA,MAMIC,EAA0BF,GAFpBG,EAJV,EAIEC,OACUC,EALZ,EAKEC,SALF,EAOmDJ,EACjDrC,GADc0C,EAPhB,EAOQH,OAA4BI,EAPpC,EAO0BF,SAI1B,OAAOH,GAAaI,GAAYF,GAAeG,EA5X5BC,CAAyB3D,EAAG4C,EAAchB,EAAIuB,aAG/D,GAA8B,IAA1BH,EAAezC,OAGjB,OAFA0B,EAAgB2B,KAAKhB,GACrBE,QAAQC,IAAI,kBAAmBH,GAC/B,WAMF,IAAMiB,EAAmB/D,IAAEgE,MAAMd,GAAgB,SAAChD,GAAD,OAsSrD,SAAuBkD,EAAoBnC,GAAoB,IAAD,EAIxDqC,EAA0BF,GAFpBG,EAFkD,EAE1DC,OACUC,EAHgD,EAG1DC,SAH0D,EAMTJ,EACjDrC,GADc0C,EAN4C,EAMpDH,OAA4BI,EANwB,EAMlCF,SAM1B,GACEC,IAAaJ,GACbK,IAAeH,GACfE,IAAaF,GACbG,IAAeL,EAEf,OAAO,EAGT,OAASI,EAAWJ,EAAaK,EAAcH,EA1T3CQ,CAAc/D,EAAG4C,MAGnB,QAAyB5B,IAArB6C,EAEF,OADAf,QAAQkB,MAAM,uBACd,QAIFlE,IAAEmE,OAAOjC,GAAgB,SAAChC,GAAD,OAAOA,EAAEM,KAAOuD,EAAiBvD,MAI1D,IAAM4D,EAiJV,SACEhB,EACAnC,EACAoC,GAMA,IAAMgB,EAAcjB,EAAY/D,OAAS4B,EAAW5B,OAC9CiF,EAAalB,EAAY9D,MAAQ2B,EAAW3B,MAE5CiF,EAAaF,EAAc,GAAKC,EAAa,EAE7CE,EAAiBpB,EAAY/D,OAAS4B,EAAW3B,MACjDmF,EAAgBrB,EAAY9D,MAAQ2B,EAAW5B,OAE/CqF,EAAYF,GAAkB,GAAKC,GAAiB,EAMpDE,EAAaC,EACjB3D,EAAW3B,MACX2B,EAAW5B,OACX+D,EACAC,GAEIwB,EAAcD,EAClB3D,EAAW5B,OACX4B,EAAW3B,MACX8D,EACAC,GAGF,GAAIkB,EACF,OAAOM,EAAYC,KAGrB,IAAKJ,GAAaC,EAAWI,YAAcF,EAAYE,YACrD,OAAOJ,EAAWG,KAGpB,OAAOD,EAAYC,KA7LAE,CAAWjB,EAAkBjB,EAAchB,EAAIuB,UAEhE,GAAwB,IAApBe,EAAS3D,OAGX,OADAwB,EAAW6B,KAAKC,GAChB,WAGF,IAAMkB,EAAOb,EAAS,GApE0C,EAsE9Bc,EAChCnB,EACAkB,EACAnD,EAAIuB,UAHE8B,EAtEwD,EAsExDA,UAAWC,EAtE6C,EAsE7CA,WAMnB,QAAkBlE,IAAdiE,EAEF,OADAnC,QAAQkB,MAAM,oBACd,QAEFiB,EAAUtE,MAAQiC,EAAajC,MAE/BgC,EAAYiB,KAAKmB,GAEbG,GACFlD,EAAe4B,KAAKsB,GAGtB,IAAMC,EAAOjB,EAAS,GAEtB,QAAalD,IAATmE,EAAoB,CAAC,IAAD,EAIlBH,EAAoBC,EAAWE,EAAMvD,EAAIuB,UAFhCiC,EAFS,EAEpBH,UACYI,EAHQ,EAGpBH,WAGF,QAAmBlE,IAAfoE,EAEF,OADAtC,QAAQwC,KAAK,wBACb,QAGFvD,EAAW6B,KAAKwB,GACZC,GACFrD,EAAe4B,KAAKyB,GAEtB1C,EAAYiB,KAAKuB,QAEjBpD,EAAW6B,KAAKqB,IArFb1C,EAAWhC,QAAQ,CAAC,IAAD,qBA4EpB,MAmBN,MAAO,CACLyB,iBACAD,aACAE,kBACAU,eASJ,SAASqC,EACPO,EACAC,EACArC,GACC,IAAD,IACA,QAAYnC,IAARwE,EAEF,OADA1C,QAAQkB,MAAM,iBACP,CAAEiB,eAAWjE,EAAWkE,gBAAYlE,GAG7C,IAAMkE,EAAapF,IAAEsC,UAAUmD,GAC/BL,EAAW5E,GAAK4B,IAEhB,IAAM+C,EAAYnF,IAAEsC,UAAUmD,GA4C9B,OA3CAN,EAAU3E,GAAK4B,IAGf+C,EAAUQ,gBAAkB,CAAEnE,KAAM,EAAGD,IAAK,GAE5C4D,EAAUhE,kBAAoByE,EAC5BH,EAActE,kBACdgE,EAAUQ,iBAGZR,EAAU3C,aAAeiD,EAAcjF,GACvC2E,EAAUhF,eAAV,UAA2BsF,EAActF,sBAAzC,QAA2DsF,EAAcjF,GAErEkF,EAAIG,eAAiBjH,EAAakH,YAEpCV,EAAW/F,QAAUqG,EAAIK,YAAc1C,EAAS2C,UAChDZ,EAAWO,gBAAkB,CAC3BpE,IAAKmE,EAAIK,YAAc1C,EAAS2C,UAChCxE,KAAM,GAGR2D,EAAU9F,OAASqG,EAAIK,cAEvBX,EAAW9F,OAASoG,EAAIK,YAAc1C,EAAS2C,UAC/CZ,EAAWO,gBAAkB,CAC3BpE,IAAK,EACLC,KAAMkE,EAAIK,YAAc1C,EAAS2C,WAGnCb,EAAU7F,MAAQoG,EAAIK,aAGxBX,EAAW/F,OAAS4G,KAAKC,IAAId,EAAW/F,OAAQ,GAChD+F,EAAW9F,MAAQ2G,KAAKC,IAAId,EAAW9F,MAAO,GAG9C8F,EAAWjE,kBAAoByE,EAC7BH,EAActE,kBACdiE,EAAWO,iBAEbP,EAAW5C,aAAeiD,EAAcjF,GACxC4E,EAAWjF,eAAX,UAA4BsF,EAActF,sBAA1C,QAA4DsF,EAAcjF,GAEnE,CAAE2E,YAAWC,cAGtB,SAASQ,EACPO,EACAC,GAUA,YARalF,IAATiF,IACFA,EAAO,CAAE5E,IAAK,EAAGC,KAAM,SAGZN,IAATkF,IACFA,EAAO,CAAE7E,IAAK,EAAGC,KAAM,IAGlB,CAAEA,KAAM2E,EAAK3E,KAAO4E,EAAK5E,KAAMD,IAAK4E,EAAK5E,IAAM6E,EAAK7E,KAuD7D,SAASqD,EACPyB,EACAC,EACAlD,EACAC,GAEA,IAEMkD,EAAmBnD,EAAY9D,MAAQ+G,EAF7B,KAGVG,EAAqBpD,EAAY/D,OAASiH,EAHhC,KAKVG,EAAOpD,EAAS2C,UAEhBU,EAA0B,CAC9Bb,aAAcjH,EAAa+H,SAC3BZ,YAAaM,EACbO,aAAcxD,EAAY5C,IAGtBqG,EAA4B,CAChChB,aAAcjH,EAAakH,WAC3BC,YAAaO,EACbM,aAAcxD,EAAY5C,IAG5B,GAAIgG,GAAsBD,EAAkB,CAC1C,IAAMO,EAA+Bb,KAAKC,IACxCI,GAAelD,EAAY9D,MAAQ+G,EAAaI,IAC/CrD,EAAY/D,OAASiH,EAAcG,GAAQrD,EAAY9D,OAGpDyH,EAA6Bd,KAAKC,IACtCG,GAAcjD,EAAY/D,OAASiH,EAAcG,IAChDrD,EAAY9D,MAAQ+G,EAAaI,GAAQrD,EAAY/D,QAGlD2H,EAA6B5D,EAAY9D,MAAQgH,EACjDW,EAA2B7D,EAAY/D,OAASgH,EAEtD,OAAIhD,EAAS6D,aACPJ,EAA+BC,EAC1B,CACLjC,KAAM,CAAC+B,EAAeH,GACtB3B,YAAa+B,GAIV,CACLhC,KAAM,CAAC4B,EAAaG,GACpB9B,YAAagC,GAIbE,EAA2BD,EACtB,CACLlC,KAAM,CAAC+B,EAAeH,GACtB3B,aAAciC,GAIX,CACLlC,KAAM,CAAC4B,EAAaG,GACpB9B,aAAckC,GAMlB,OAAIV,EAGK,CAAEzB,KAAM,CAAC4B,GAAc3B,YAAaoC,OAAOC,UAAY,GAG5DZ,EAGK,CAAE1B,KAAM,CAAC+B,GAAgB9B,YAAaoC,OAAOC,UAAY,GAG3D,CAAEtC,KAAM,GAAIC,YAAaoC,OAAOC,WA2BzC,SAASxE,EAAcyE,EAAeC,GAAe,MAGRhE,EAA0B+D,GAArDE,EAHmC,EAG3C/D,OAAwBgE,EAHmB,EAG7B9D,SAH6B,EAIRJ,EAA0BgE,GAArDG,EAJmC,EAI3CjE,OAAwBkE,EAJmB,EAI7BhE,SAGtB,OAAI6D,EAAOE,GACD,EAINF,EAAOE,EACF,EAKLD,EAASE,GACH,EAGNF,EAASE,EACJ,EAGF,EAGT,SAASpE,EAA0B+D,GAGjC,MAAO,CAAE7D,OAFMyC,KAAKC,IAAImB,EAAOhI,OAAQgI,EAAO/H,OAE7BoE,SADAuC,KAAK0B,IAAIN,EAAOhI,OAAQgI,EAAO/H,QA0FlD,IAAMsI,EAAe,WC/dRC,EAAb,kDACE,WAAY/I,GAAkB,IAAD,8BAC3B,cAAMA,IAEDC,MAAQ,CACX+I,UAjBU,y2CAkBVhG,SAAKZ,EACL6G,aAAS7G,EACT8G,SAAU,OACVd,cAAc,GARW,EAD/B,4GAeqBlI,EAAqBC,MAf1C,+BAiBY,INnCwBT,EMmCzB,OACP,OACE,sBAAKgC,GAAG,YAAR,UACE,8CAEA,gCACE,0BACE7B,MAAOQ,KAAKJ,MAAM+I,UAClBG,SAAU1J,GAAmB,SAACuJ,GAAD,OAC3B,EAAKI,SAAS,CAAEJ,mBAIpB,uBACEnJ,MAAOQ,KAAKJ,MAAMiJ,SAClBC,SAAU1J,GAAmB,SAACyJ,GAAD,OAC3B,EAAKE,SAAS,CAAEF,kBAIpB,8BACE,uBACEG,KAAK,WACLC,QAASjJ,KAAKJ,MAAMmI,aACpBe,UN3DsBzJ,EM2DQ,SAAC0I,GAAD,OAC5B,EAAKgB,SAAS,CAAEhB,kBN3DvB,SAACzI,GAAD,OACLD,EAASC,EAAMC,OAA4B0J,aMqDrC,oBAWA,wBAAQC,QAAS,kBAAM,EAAKC,sBAA5B,0BAEF,gCACE,yCACA,cAAC,EAAD,CAAWxG,IAAK3C,KAAKJ,MAAM+C,IAAKC,OAAQ5C,KAAKJ,MAAMgJ,kBApD7D,2CA4DI,IAAMQ,ED+VH,SAAyBC,GAC9BpG,EAAS,EAGT,IAJ6C,EAIvCqG,EAAQD,EAAME,MAAM,MAEpB5G,EAAc,CAClBE,gBAAiB,GACjBU,aAAc,GACdW,SAAU,CAAE2C,UAAW,IAAMkB,cAAc,IAGzCyB,GAAU,EAZ+B,cAc5BF,GAd4B,IAc7C,2BAAwB,CAAC,IAAhBG,EAAe,QACtB,GAAID,EACFA,GAAU,OAIZ,GAAoB,KAAhBC,EAAKC,OAAT,CAIA,IAAMC,EAAQF,EAAKF,MAAM,KAWrBrJ,GAAUyJ,EAAM,GAAGC,WAAWnB,EAAc,IAC5CtI,GAASwJ,EAAM,GAAGC,WAAWnB,EAAc,IACzCoB,GAAOF,EAAM,GACbtJ,EAAWsJ,EAAM,GACjBjI,EAAQiI,EAAM,GACdG,EAA8C,SAAlCH,EAAM,GAAGD,OAAOK,cAGlC,GAAI7J,EAASC,EAAO,CAAC,IAAD,EACA,CAACA,EAAOD,GAAzBA,EADiB,KACTC,EADS,KAIpB,IAAK,IAAI6J,EAAI,EAAGA,GAAKH,EAAKG,IAAK,CAC7B,IACMC,EAAkB,CACtB/J,SACAC,QACAkB,GAAI4B,IACJ5C,WACAqB,MANiBmI,EAAM,EAAInI,EAAQ,IAAMsI,EAAItI,GAS3CoI,EACFnH,EAAIE,gBAAgB8B,KAAKsF,GAEzBtH,EAAIY,aAAaoB,KAAKsF,MA5DiB,8BAiE7C,OAAOtH,EChaUuH,CAAgBlK,KAAKJ,MAAM+I,WAE1CS,EAAOlF,SAAS2C,WAAa7G,KAAKJ,MAAMiJ,SACxCO,EAAOlF,SAAS6D,aAAe/H,KAAKJ,MAAMmI,aAE1ClE,QAAQC,IAAI,YAAasF,GAEzB,IAAMR,EAAU1F,EAAwBkG,GAExCvF,QAAQC,IAAI,SAAU8E,GAEtB5I,KAAK+I,SAAS,CAAEpG,IAAKyG,EAAQR,gBAvEjC,GAAyBtI,IAAMC,WCLhB4J,G,MAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,QCFdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.678e4d1b.chunk.js","sourcesContent":["/** Event handler that exposes the target element's value as a boolean. */\nexport function handleBooleanChange(handler: (checked: boolean) => void) {\n  return (event: React.FormEvent<HTMLElement>) =>\n    handler((event.target as HTMLInputElement).checked);\n}\n\n/** Event handler that exposes the target element's value as a string. */\nexport function handleStringChange(handler: (value: string) => void) {\n  return (event: React.FormEvent<HTMLElement>) =>\n    handler((event.target as HTMLInputElement).value);\n}\n\n/** Event handler that exposes the target element's value as a number. */\nexport function handleNumberChange(handler: (value: number) => void) {\n  return handleStringChange((value) => handler(+value));\n}\n","type PanelId = number;\n\nexport interface Panel {\n  height: number;\n  width: number;\n\n  material: string;\n\n  id: PanelId;\n\n  label: string;\n\n  originalSource?: PanelId;\n  parentSource?: PanelId;\n\n  /** determines from where panel started from its parent */\n  parentSourcePos?: PanelPos;\n  originalSourcePos?: PanelPos;\n}\n\nexport interface PanelPos {\n  top: number;\n  left: number;\n}\nexport interface CutJob {\n  availablePanels: Panel[];\n  neededPanels: Panel[];\n  settings: CutJobSetting;\n}\n\nexport enum CutDirection {\n  VERTICAL = 1,\n  HORIZONTAL = 2,\n}\n\nexport interface CutJobStep {\n  panelIdToCut: PanelId;\n  cutDirection: CutDirection;\n\n  /** distance from the nominal corner */\n  cutPosition: number;\n}\n\nexport interface CutJobResults {\n  panelInventory: Panel[];\n  panelsMade: Panel[];\n  panelsNotPlaced: Panel[];\n  cutsInOrder: CutJobStep[];\n}\n\nexport interface CutJobSetting {\n  bladeKerf: number;\n\n  optimizeArea: boolean;\n}\n","import React from \"react\";\nimport { Panel } from \"./model\";\n\ninterface PanelProps {\n  panel: Panel;\n}\ninterface PanelState {}\n\nexport class PanelComp extends React.Component<PanelProps, PanelState> {\n  constructor(props: PanelProps) {\n    super(props);\n\n    this.state = {};\n  }\n\n  componentDidMount() {}\n\n  componentDidUpdate(prevProps: PanelProps, prevState: PanelState) {}\n\n  render() {\n    const panel = this.props.panel;\n    return (\n      <div\n        style={{\n          height: panel.height * 5,\n          width: panel.width * 5,\n          border: \"1px solid black\",\n        }}\n      >\n        {panel.material + \"\\n\" + panel.height + \"\\n\" + panel.width}\n      </div>\n    );\n  }\n}\n","import _ from \"lodash\";\nimport React from \"react\";\n\nimport { Panel } from \"./model\";\nimport { PanelComp } from \"./Panel\";\n\ninterface JobPanelViewerProps {\n  startPanels: Panel[];\n  madePanels: Panel[];\n  inventoryPanels: Panel[];\n  notMadePanels: Panel[];\n}\ninterface JobPanelViewerState {}\n\nexport class JobPanelViewer extends React.Component<\n  JobPanelViewerProps,\n  JobPanelViewerState\n> {\n  constructor(props: JobPanelViewerProps) {\n    super(props);\n\n    this.state = {};\n  }\n\n  componentDidMount() {}\n\n  componentDidUpdate(\n    prevProps: JobPanelViewerProps,\n    prevState: JobPanelViewerState\n  ) {}\n\n  render() {\n    const panelsToGroup = [\n      ...this.props.madePanels,\n      ...this.props.inventoryPanels,\n    ];\n    // built list of all panels and assemble parent/child\n\n    // group by original source\n\n    const groups = _.groupBy(panelsToGroup, (c) => c.originalSource);\n\n    return (\n      <div>\n        {this.props.notMadePanels.map((panel) => {\n          return <PanelComp panel={panel} />;\n        })}\n\n        {this.props.startPanels.map((panel) => {\n          const childPanels = groups[panel.id];\n\n          // will only have itself if none used\n          if (childPanels.length === 1) {\n            return null;\n          }\n\n          return (\n            <div\n              style={{\n                marginTop: 20,\n                pageBreakInside: \"avoid\",\n                WebkitPrintColorAdjust: \"exact\",\n              }}\n              key={panel.id}\n            >\n              <p>\n                {panel.label} - {panel.height} x {panel.width}\n              </p>\n              <div style={{ display: \"flex\" }}>\n                <div\n                  style={{\n                    height: panel.height * 5,\n                    width: panel.width * 5,\n                    border: \"1px solid black\",\n                    position: \"relative\",\n                    backgroundColor: \"red\",\n                  }}\n                >\n                  {childPanels.map((childPanel) => {\n                    if (\n                      childPanel.originalSourcePos === undefined ||\n                      childPanel.height <= 0 ||\n                      childPanel.width <= 0\n                    ) {\n                      return null;\n                    }\n\n                    const isInventory = this.props.inventoryPanels.includes(\n                      childPanel\n                    );\n\n                    const displayText = isInventory ? \"\" : childPanel.id;\n                    return (\n                      <div\n                        key={childPanel.id}\n                        style={{\n                          height: childPanel.height * 5,\n                          width: childPanel.width * 5,\n                          border: \"1px dashed #000\",\n                          position: \"absolute\",\n                          top: childPanel.originalSourcePos.top * 5,\n                          left: childPanel.originalSourcePos.left * 5,\n                          backgroundColor: isInventory ? \"#ddd\" : \"white\",\n                          display: \"flex\",\n                          justifyContent: \"center\",\n                          alignItems: \"center\",\n                        }}\n                      >\n                        <p>{displayText}</p>\n                      </div>\n                    );\n                  })}\n                </div>\n                <div style={{ marginLeft: 10 }}>\n                  {childPanels.map((child) => {\n                    const isInventory = this.props.inventoryPanels.includes(\n                      child\n                    );\n\n                    if (isInventory) {\n                      return null;\n                    }\n\n                    return (\n                      <p key={child.id}>\n                        {child.id} - {child.label} - {child.height} x{\" \"}\n                        {child.width}\n                      </p>\n                    );\n                  })}\n                </div>\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport { JobPanelViewer } from \"./JobPanelViewer\";\nimport { CutJob, CutJobResults } from \"./model\";\nimport { PanelComp } from \"./Panel\";\nimport { PanelContainer } from \"./PanelContainer\";\n\ninterface JobViewerProps {\n  job?: CutJob;\n  result?: CutJobResults;\n}\ninterface JobViewerState {}\n\nexport class JobViewer extends React.Component<JobViewerProps, JobViewerState> {\n  constructor(props: JobViewerProps) {\n    super(props);\n\n    this.state = {};\n  }\n\n  componentDidMount() {}\n\n  componentDidUpdate(prevProps: JobViewerProps, prevState: JobViewerState) {}\n\n  render() {\n    const job = this.props.job;\n    const result = this.props.result;\n\n    if (job === undefined || result === undefined) {\n      return \"job or result undefined...\";\n    }\n\n    return (\n      <div>\n        <JobPanelViewer\n          startPanels={job.availablePanels}\n          madePanels={result.panelsMade}\n          inventoryPanels={result.panelInventory}\n          notMadePanels={result.panelsNotPlaced}\n        />\n      </div>\n    );\n  }\n}\n","import _ from \"lodash\";\nimport {\n  CutDirection,\n  CutJob,\n  CutJobResults,\n  CutJobSetting,\n  CutJobStep,\n  Panel,\n  PanelPos,\n} from \"./model\";\n\nlet nextId = 1;\n\nexport function determineCutOrderForJob(job: CutJob): CutJobResults {\n  // steps\n\n  // sort the panels and process in order\n\n  const panelInventory = _.cloneDeep(job.availablePanels);\n\n  // inventory points to itself\n  panelInventory.forEach((c) => {\n    c.originalSource = c.id;\n    c.parentSource = c.id;\n  });\n\n  const panelsNeed = _.cloneDeep(job.neededPanels);\n  panelsNeed.sort(comparePanels);\n\n  const panelsNotPlaced = [];\n  const panelsMade = [];\n  const cutsInOrder = [];\n\n  // pick the biggest piece that is needed\n\n  while (panelsNeed.length) {\n    const panelToPlace = panelsNeed.shift();\n\n    if (panelToPlace === undefined) {\n      console.log(\"panel was undefined\");\n      break;\n    }\n\n    // find all panels that can hold it\n\n    const panelsToHoldIt = panelInventory\n      .filter((c) => c.material === panelToPlace.material)\n      .filter((c) => willFirstPanelHoldSecond(c, panelToPlace, job.settings));\n\n    // nowhere to put it - add to bad list\n    if (panelsToHoldIt.length === 0) {\n      panelsNotPlaced.push(panelToPlace);\n      console.log(\"could not place\", panelToPlace);\n      continue;\n    }\n\n    // choose the best panel that can hold it\n    // compute a \"waste\"\n\n    const bestHoldingPanel = _.maxBy(panelsToHoldIt, (c) =>\n      getPanelWaste(c, panelToPlace)\n    );\n\n    if (bestHoldingPanel === undefined) {\n      console.error(\"could not find best\");\n      break;\n    }\n\n    // remove the known panel since it's going to be split\n    _.remove(panelInventory, (c) => c.id === bestHoldingPanel.id);\n\n    // choose best direction on that panel\n    // create job steps for each of the cuts needed (may only be one)\n    const bestCuts = getBestCut(bestHoldingPanel, panelToPlace, job.settings);\n\n    if (bestCuts.length === 0) {\n      // new panel is perfect size -- no cuts needed\n      panelsMade.push(bestHoldingPanel);\n      continue;\n    }\n\n    const cut1 = bestCuts[0];\n\n    const { goodPanel, wastePanel } = getNewPanelsFromCut(\n      bestHoldingPanel,\n      cut1,\n      job.settings\n    );\n\n    if (goodPanel === undefined) {\n      console.error(\"failed on a cut?\");\n      break;\n    }\n    goodPanel.label = panelToPlace.label;\n\n    cutsInOrder.push(cut1);\n\n    if (wastePanel) {\n      panelInventory.push(wastePanel);\n    }\n\n    const cut2 = bestCuts[1];\n\n    if (cut2 !== undefined) {\n      const {\n        goodPanel: finalPanel,\n        wastePanel: wastePanel2,\n      } = getNewPanelsFromCut(goodPanel, cut2, job.settings);\n\n      if (finalPanel === undefined) {\n        console.warn(\"panel was undefined?\");\n        break;\n      }\n\n      panelsMade.push(finalPanel);\n      if (wastePanel2) {\n        panelInventory.push(wastePanel2);\n      }\n      cutsInOrder.push(cut2);\n    } else {\n      panelsMade.push(goodPanel);\n    }\n\n    // make cut\n    // update the panel inventory based on those cuts and kerf\n\n    // repeat this loop, storing job steps and panel list\n  }\n  // when done... return results...\n\n  return {\n    panelInventory,\n    panelsMade,\n    panelsNotPlaced,\n    cutsInOrder,\n  };\n}\n\n/**\n * Will supply the results of a cut without modifying originals\n * @param originalPanel Panel to cut - will not be modified\n * @param cut Cut applied to that panel\n */\nfunction getNewPanelsFromCut(\n  originalPanel: Panel,\n  cut: CutJobStep | undefined,\n  settings: CutJobSetting\n) {\n  if (cut === undefined) {\n    console.error(\"cut undefined\");\n    return { goodPanel: undefined, wastePanel: undefined };\n  }\n\n  const wastePanel = _.cloneDeep(originalPanel);\n  wastePanel.id = nextId++;\n\n  const goodPanel = _.cloneDeep(originalPanel);\n  goodPanel.id = nextId++;\n\n  // TODO: include steps to get back raw source from here\n  goodPanel.parentSourcePos = { left: 0, top: 0 };\n\n  goodPanel.originalSourcePos = addSourcePos(\n    originalPanel.originalSourcePos,\n    goodPanel.parentSourcePos\n  );\n\n  goodPanel.parentSource = originalPanel.id;\n  goodPanel.originalSource = originalPanel.originalSource ?? originalPanel.id;\n\n  if (cut.cutDirection === CutDirection.HORIZONTAL) {\n    // this will reduce the height by position\n    wastePanel.height -= cut.cutPosition + settings.bladeKerf;\n    wastePanel.parentSourcePos = {\n      top: cut.cutPosition + settings.bladeKerf,\n      left: 0,\n    };\n\n    goodPanel.height = cut.cutPosition;\n  } else {\n    wastePanel.width -= cut.cutPosition + settings.bladeKerf;\n    wastePanel.parentSourcePos = {\n      top: 0,\n      left: cut.cutPosition + settings.bladeKerf,\n    };\n\n    goodPanel.width = cut.cutPosition;\n  }\n\n  wastePanel.height = Math.max(wastePanel.height, 0);\n  wastePanel.width = Math.max(wastePanel.width, 0);\n\n  // update waste panel pos\n  wastePanel.originalSourcePos = addSourcePos(\n    originalPanel.originalSourcePos,\n    wastePanel.parentSourcePos\n  );\n  wastePanel.parentSource = originalPanel.id;\n  wastePanel.originalSource = originalPanel.originalSource ?? originalPanel.id;\n\n  return { goodPanel, wastePanel };\n}\n\nfunction addSourcePos(\n  pos1: PanelPos | undefined,\n  pos2: PanelPos | undefined\n): PanelPos {\n  if (pos1 === undefined) {\n    pos1 = { top: 0, left: 0 };\n  }\n\n  if (pos2 === undefined) {\n    pos2 = { top: 0, left: 0 };\n  }\n\n  return { left: pos1.left + pos2.left, top: pos1.top + pos2.top };\n}\n\nfunction getBestCut(\n  parentPanel: Panel,\n  childPanel: Panel,\n  settings: CutJobSetting\n): CutJobStep[] {\n  // test if the piece should be rotated -- will do the calc twice\n\n  // do this based on keeping the largest biggest area pieces\n\n  const wasteHeight = parentPanel.height - childPanel.height;\n  const wasteWidth = parentPanel.width - childPanel.width;\n\n  const mustRotate = wasteHeight < 0 || wasteWidth < 0;\n\n  const wasteHeightRot = parentPanel.height - childPanel.width;\n  const wasteWidthRot = parentPanel.width - childPanel.height;\n\n  const canRotate = wasteHeightRot >= 0 && wasteWidthRot >= 0;\n\n  // first cut is for the height\n\n  // figure out if rotating is better\n\n  const normalCuts = getBestCutSingleTest(\n    childPanel.width,\n    childPanel.height,\n    parentPanel,\n    settings\n  );\n  const rotatedCuts = getBestCutSingleTest(\n    childPanel.height,\n    childPanel.width,\n    parentPanel,\n    settings\n  );\n\n  if (mustRotate) {\n    return rotatedCuts.cuts;\n  }\n\n  if (!canRotate || normalCuts.biggestArea > rotatedCuts.biggestArea) {\n    return normalCuts.cuts;\n  }\n\n  return rotatedCuts.cuts;\n}\n\ninterface CutTestResult {\n  cuts: CutJobStep[];\n  biggestArea: number;\n}\n\nfunction getBestCutSingleTest(\n  widthToUse: number,\n  heightToUse: number,\n  parentPanel: Panel,\n  settings: CutJobSetting\n): CutTestResult {\n  const epsilon = 0.001;\n\n  const needsVerticalCut = parentPanel.width - widthToUse > epsilon;\n  const needsHorizontalCut = parentPanel.height - heightToUse > epsilon;\n\n  const kerf = settings.bladeKerf;\n\n  const verticalCut: CutJobStep = {\n    cutDirection: CutDirection.VERTICAL,\n    cutPosition: widthToUse,\n    panelIdToCut: parentPanel.id,\n  };\n\n  const horizontalCut: CutJobStep = {\n    cutDirection: CutDirection.HORIZONTAL,\n    cutPosition: heightToUse,\n    panelIdToCut: parentPanel.id,\n  };\n\n  if (needsHorizontalCut && needsVerticalCut) {\n    const biggestAreaIfHorizontalFirst = Math.max(\n      heightToUse * (parentPanel.width - widthToUse - kerf),\n      (parentPanel.height - heightToUse - kerf) * parentPanel.width\n    );\n\n    const biggestAreaIfVerticalFirst = Math.max(\n      widthToUse * (parentPanel.height - heightToUse - kerf),\n      (parentPanel.width - widthToUse - kerf) * parentPanel.height\n    );\n\n    const cutLengthIfHorizontalFirst = parentPanel.width + heightToUse;\n    const cutLengthIfVerticalFirst = parentPanel.height + widthToUse;\n\n    if (settings.optimizeArea) {\n      if (biggestAreaIfHorizontalFirst > biggestAreaIfVerticalFirst) {\n        return {\n          cuts: [horizontalCut, verticalCut],\n          biggestArea: biggestAreaIfHorizontalFirst,\n        };\n      }\n\n      return {\n        cuts: [verticalCut, horizontalCut],\n        biggestArea: biggestAreaIfVerticalFirst,\n      };\n    }\n\n    if (cutLengthIfVerticalFirst > cutLengthIfHorizontalFirst) {\n      return {\n        cuts: [horizontalCut, verticalCut],\n        biggestArea: -cutLengthIfHorizontalFirst,\n      };\n    }\n\n    return {\n      cuts: [verticalCut, horizontalCut],\n      biggestArea: -cutLengthIfVerticalFirst,\n    };\n  }\n\n  // TODO: determine the order here based on biggest single piece\n\n  if (needsVerticalCut) {\n    // add the height job = VERTICAL cut\n\n    return { cuts: [verticalCut], biggestArea: Number.MAX_VALUE / 2 };\n  }\n\n  if (needsHorizontalCut) {\n    // add the height job = HORIZONTAL cut\n\n    return { cuts: [horizontalCut], biggestArea: Number.MAX_VALUE / 2 };\n  }\n\n  return { cuts: [], biggestArea: Number.MAX_VALUE };\n}\n\nfunction getPanelWaste(parentPanel: Panel, childPanel: Panel) {\n  const {\n    bigDim: parentBig,\n    smallDim: parentSmall,\n  } = getBigAndSmallSideOfPanel(parentPanel);\n\n  const { bigDim: childBig, smallDim: childSmall } = getBigAndSmallSideOfPanel(\n    childPanel\n  );\n\n  // short circuit for exact match\n\n  if (\n    childBig === parentBig ||\n    childSmall === parentSmall ||\n    childBig === parentSmall ||\n    childSmall === parentBig\n  ) {\n    return 1;\n  }\n\n  return ((childBig / parentBig) * childSmall) / parentSmall;\n}\n\nfunction comparePanels(panelA: Panel, panelB: Panel) {\n  // compare biggest dim against biggest dim\n\n  const { bigDim: aBig, smallDim: aSmall } = getBigAndSmallSideOfPanel(panelA);\n  const { bigDim: bBig, smallDim: bSmall } = getBigAndSmallSideOfPanel(panelB);\n\n  // a is bigger\n  if (aBig > bBig) {\n    return -1;\n  }\n\n  // b is bigger\n  if (aBig < bBig) {\n    return 1;\n  }\n\n  // check the smaller dimension\n\n  if (aSmall > bSmall) {\n    return -1;\n  }\n\n  if (aSmall < bSmall) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction getBigAndSmallSideOfPanel(panelA: Panel) {\n  const bigDim = Math.max(panelA.height, panelA.width);\n  const smallDim = Math.min(panelA.height, panelA.width);\n  return { bigDim, smallDim };\n}\n\nfunction willFirstPanelHoldSecond(\n  parentPanel: Panel,\n  childPanel: Panel,\n  settings: CutJobSetting\n) {\n  // it will fit if the biggest dimension is bigger or equal and smaller is also bigger or equal\n\n  const {\n    bigDim: parentBig,\n    smallDim: parentSmall,\n  } = getBigAndSmallSideOfPanel(parentPanel);\n  const { bigDim: childBig, smallDim: childSmall } = getBigAndSmallSideOfPanel(\n    childPanel\n  );\n\n  return parentBig >= childBig && parentSmall >= childSmall;\n}\n\nexport function convertCsvToJob(input: string) {\n  nextId = 1;\n  // read the input into lines\n\n  const lines = input.split(\"\\n\");\n\n  const job: CutJob = {\n    availablePanels: [],\n    neededPanels: [],\n    settings: { bladeKerf: 0.25, optimizeArea: false },\n  };\n\n  let isFirst = true;\n\n  for (let line of lines) {\n    if (isFirst) {\n      isFirst = false;\n      continue;\n    }\n\n    if (line.trim() === \"\") {\n      continue;\n    }\n\n    const parts = line.split(\",\");\n\n    /**\n     * \nLength,Width,Quantity,Material,Label,Inventory\n20 in,16 in,6,0.5 in,Side L,\n17.375 in,16 in,3,0.5 in,False Front,\n48 in,96 in,3,0.5 in,1/2 PLY,True\n     */\n\n    // force height and width to only be numbers\n    let height = +parts[0].replaceAll(numOnlyRegex, \"\");\n    let width = +parts[1].replaceAll(numOnlyRegex, \"\");\n    const qty = +parts[2];\n    const material = parts[3];\n    const label = parts[4];\n    const inventory = parts[5].trim().toLowerCase() === \"true\";\n\n    // force width to be bigger\n    if (height > width) {\n      [height, width] = [width, height];\n    }\n\n    for (let i = 1; i <= qty; i++) {\n      const labelToUse = qty > 1 ? label + \"-\" + i : label;\n      const newPanel: Panel = {\n        height,\n        width,\n        id: nextId++,\n        material,\n        label: labelToUse,\n      };\n\n      if (inventory) {\n        job.availablePanels.push(newPanel);\n      } else {\n        job.neededPanels.push(newPanel);\n      }\n    }\n  }\n\n  return job;\n}\n\nconst numOnlyRegex = /[^0-9.]/g;\n","import React from \"react\";\nimport { handleBooleanChange, handleStringChange } from \"./helpers\";\nimport { JobViewer } from \"./JobViewer\";\nimport { CutJob, CutJobResults } from \"./model\";\nimport { convertCsvToJob, determineCutOrderForJob } from \"./PanelOperations\";\n\nimport raw from \"raw.macro\";\nconst defaultJob = raw(\"./cut list.csv\");\n\ninterface AppProps {}\ninterface AppState {\n  inputText: string;\n  kerfText: string;\n  optimizeArea: boolean;\n\n  job: CutJob | undefined;\n  results: CutJobResults | undefined;\n}\n\nexport class App extends React.Component<AppProps, AppState> {\n  constructor(props: AppProps) {\n    super(props);\n\n    this.state = {\n      inputText: defaultJob,\n      job: undefined,\n      results: undefined,\n      kerfText: \"0.25\",\n      optimizeArea: false,\n    };\n  }\n\n  componentDidMount() {}\n\n  componentDidUpdate(prevProps: AppProps, prevState: AppState) {}\n\n  render() {\n    return (\n      <div id=\"container\">\n        <h1>sheet cutter</h1>\n\n        <div>\n          <textarea\n            value={this.state.inputText}\n            onChange={handleStringChange((inputText) =>\n              this.setState({ inputText })\n            )}\n          />\n\n          <input\n            value={this.state.kerfText}\n            onChange={handleStringChange((kerfText) =>\n              this.setState({ kerfText })\n            )}\n          />\n\n          <p>\n            <input\n              type=\"checkbox\"\n              checked={this.state.optimizeArea}\n              onChange={handleBooleanChange((optimizeArea) =>\n                this.setState({ optimizeArea })\n              )}\n            />\n            optimize area?\n          </p>\n\n          <button onClick={() => this.handleProcessClick()}>process !</button>\n        </div>\n        <div>\n          <h2>results</h2>\n          <JobViewer job={this.state.job} result={this.state.results} />\n        </div>\n      </div>\n    );\n  }\n  handleProcessClick(): void {\n    // get the input and send to job creation\n\n    const newJob = convertCsvToJob(this.state.inputText);\n\n    newJob.settings.bladeKerf = +this.state.kerfText;\n    newJob.settings.optimizeArea = this.state.optimizeArea;\n\n    console.log(\"job start\", newJob);\n\n    const results = determineCutOrderForJob(newJob);\n\n    console.log(\"result\", results);\n\n    this.setState({ job: newJob, results });\n  }\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./App\";\nimport \"./index.css\";\n\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}